// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nebula.proto

package nebula

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NebulaMeta_MessageType int32

const (
	NebulaMeta_None                      NebulaMeta_MessageType = 0
	NebulaMeta_HostQuery                 NebulaMeta_MessageType = 1
	NebulaMeta_HostQueryReply            NebulaMeta_MessageType = 2
	NebulaMeta_HostUpdateNotification    NebulaMeta_MessageType = 3
	NebulaMeta_HostMovedNotification     NebulaMeta_MessageType = 4
	NebulaMeta_HostPunchNotification     NebulaMeta_MessageType = 5
	NebulaMeta_HostWhoami                NebulaMeta_MessageType = 6
	NebulaMeta_HostWhoamiReply           NebulaMeta_MessageType = 7
	NebulaMeta_PathCheck                 NebulaMeta_MessageType = 8
	NebulaMeta_PathCheckReply            NebulaMeta_MessageType = 9
	NebulaMeta_HostUpdateNotificationAck NebulaMeta_MessageType = 10
)

var NebulaMeta_MessageType_name = map[int32]string{
	0:  "None",
	1:  "HostQuery",
	2:  "HostQueryReply",
	3:  "HostUpdateNotification",
	4:  "HostMovedNotification",
	5:  "HostPunchNotification",
	6:  "HostWhoami",
	7:  "HostWhoamiReply",
	8:  "PathCheck",
	9:  "PathCheckReply",
	10: "HostUpdateNotificationAck",
}

var NebulaMeta_MessageType_value = map[string]int32{
	"None":                      0,
	"HostQuery":                 1,
	"HostQueryReply":            2,
	"HostUpdateNotification":    3,
	"HostMovedNotification":     4,
	"HostPunchNotification":     5,
	"HostWhoami":                6,
	"HostWhoamiReply":           7,
	"PathCheck":                 8,
	"PathCheckReply":            9,
	"HostUpdateNotificationAck": 10,
}

func (x NebulaMeta_MessageType) String() string {
	return proto.EnumName(NebulaMeta_MessageType_name, int32(x))
}

func (NebulaMeta_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0, 0}
}

type NebulaPing_MessageType int32

const (
	NebulaPing_Ping  NebulaPing_MessageType = 0
	NebulaPing_Reply NebulaPing_MessageType = 1
)

var NebulaPing_MessageType_name = map[int32]string{
	0: "Ping",
	1: "Reply",
}

var NebulaPing_MessageType_value = map[string]int32{
	"Ping":  0,
	"Reply": 1,
}

func (x NebulaPing_MessageType) String() string {
	return proto.EnumName(NebulaPing_MessageType_name, int32(x))
}

func (NebulaPing_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{5, 0}
}

type NebulaControl_MessageType int32

const (
	NebulaControl_None                NebulaControl_MessageType = 0
	NebulaControl_CreateRelayRequest  NebulaControl_MessageType = 1
	NebulaControl_CreateRelayResponse NebulaControl_MessageType = 2
)

var NebulaControl_MessageType_name = map[int32]string{
	0: "None",
	1: "CreateRelayRequest",
	2: "CreateRelayResponse",
}

var NebulaControl_MessageType_value = map[string]int32{
	"None":                0,
	"CreateRelayRequest":  1,
	"CreateRelayResponse": 2,
}

func (x NebulaControl_MessageType) String() string {
	return proto.EnumName(NebulaControl_MessageType_name, int32(x))
}

func (NebulaControl_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{8, 0}
}

type NebulaMeta struct {
	Type    NebulaMeta_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaMeta_MessageType" json:"Type,omitempty"`
	Details *NebulaMetaDetails     `protobuf:"bytes,2,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (m *NebulaMeta) Reset()         { *m = NebulaMeta{} }
func (m *NebulaMeta) String() string { return proto.CompactTextString(m) }
func (*NebulaMeta) ProtoMessage()    {}
func (*NebulaMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0}
}
func (m *NebulaMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMeta.Merge(m, src)
}
func (m *NebulaMeta) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMeta.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMeta proto.InternalMessageInfo

func (m *NebulaMeta) GetType() NebulaMeta_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaMeta_None
}

func (m *NebulaMeta) GetDetails() *NebulaMetaDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type NebulaMetaDetails struct {
	VpnIp       *Ip           `protobuf:"bytes,1,opt,name=VpnIp,proto3" json:"VpnIp,omitempty"`
	Ip4AndPorts []*Ip4AndPort `protobuf:"bytes,2,rep,name=Ip4AndPorts,proto3" json:"Ip4AndPorts,omitempty"`
	Ip6AndPorts []*Ip6AndPort `protobuf:"bytes,4,rep,name=Ip6AndPorts,proto3" json:"Ip6AndPorts,omitempty"`
	RelayVpnIp  []*Ip         `protobuf:"bytes,5,rep,name=RelayVpnIp,proto3" json:"RelayVpnIp,omitempty"`
	Counter     uint32        `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
}

func (m *NebulaMetaDetails) Reset()         { *m = NebulaMetaDetails{} }
func (m *NebulaMetaDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaMetaDetails) ProtoMessage()    {}
func (*NebulaMetaDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{1}
}
func (m *NebulaMetaDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMetaDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMetaDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMetaDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMetaDetails.Merge(m, src)
}
func (m *NebulaMetaDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMetaDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMetaDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMetaDetails proto.InternalMessageInfo

func (m *NebulaMetaDetails) GetVpnIp() *Ip {
	if m != nil {
		return m.VpnIp
	}
	return nil
}

func (m *NebulaMetaDetails) GetIp4AndPorts() []*Ip4AndPort {
	if m != nil {
		return m.Ip4AndPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetIp6AndPorts() []*Ip6AndPort {
	if m != nil {
		return m.Ip6AndPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetRelayVpnIp() []*Ip {
	if m != nil {
		return m.RelayVpnIp
	}
	return nil
}

func (m *NebulaMetaDetails) GetCounter() uint32 {
	if m != nil {
		return m.Counter
	}
	return 0
}

type Ip struct {
	Hi uint64 `protobuf:"varint,1,opt,name=Hi,proto3" json:"Hi,omitempty"`
	Lo uint64 `protobuf:"varint,2,opt,name=Lo,proto3" json:"Lo,omitempty"`
}

func (m *Ip) Reset()         { *m = Ip{} }
func (m *Ip) String() string { return proto.CompactTextString(m) }
func (*Ip) ProtoMessage()    {}
func (*Ip) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{2}
}
func (m *Ip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ip.Merge(m, src)
}
func (m *Ip) XXX_Size() int {
	return m.Size()
}
func (m *Ip) XXX_DiscardUnknown() {
	xxx_messageInfo_Ip.DiscardUnknown(m)
}

var xxx_messageInfo_Ip proto.InternalMessageInfo

func (m *Ip) GetHi() uint64 {
	if m != nil {
		return m.Hi
	}
	return 0
}

func (m *Ip) GetLo() uint64 {
	if m != nil {
		return m.Lo
	}
	return 0
}

type Ip4AndPort struct {
	Ip   uint32 `protobuf:"varint,1,opt,name=Ip,proto3" json:"Ip,omitempty"`
	Port uint32 `protobuf:"varint,2,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *Ip4AndPort) Reset()         { *m = Ip4AndPort{} }
func (m *Ip4AndPort) String() string { return proto.CompactTextString(m) }
func (*Ip4AndPort) ProtoMessage()    {}
func (*Ip4AndPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{3}
}
func (m *Ip4AndPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ip4AndPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ip4AndPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ip4AndPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ip4AndPort.Merge(m, src)
}
func (m *Ip4AndPort) XXX_Size() int {
	return m.Size()
}
func (m *Ip4AndPort) XXX_DiscardUnknown() {
	xxx_messageInfo_Ip4AndPort.DiscardUnknown(m)
}

var xxx_messageInfo_Ip4AndPort proto.InternalMessageInfo

func (m *Ip4AndPort) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *Ip4AndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Ip6AndPort struct {
	Hi   uint64 `protobuf:"varint,1,opt,name=Hi,proto3" json:"Hi,omitempty"`
	Lo   uint64 `protobuf:"varint,2,opt,name=Lo,proto3" json:"Lo,omitempty"`
	Port uint32 `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *Ip6AndPort) Reset()         { *m = Ip6AndPort{} }
func (m *Ip6AndPort) String() string { return proto.CompactTextString(m) }
func (*Ip6AndPort) ProtoMessage()    {}
func (*Ip6AndPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{4}
}
func (m *Ip6AndPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ip6AndPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ip6AndPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ip6AndPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ip6AndPort.Merge(m, src)
}
func (m *Ip6AndPort) XXX_Size() int {
	return m.Size()
}
func (m *Ip6AndPort) XXX_DiscardUnknown() {
	xxx_messageInfo_Ip6AndPort.DiscardUnknown(m)
}

var xxx_messageInfo_Ip6AndPort proto.InternalMessageInfo

func (m *Ip6AndPort) GetHi() uint64 {
	if m != nil {
		return m.Hi
	}
	return 0
}

func (m *Ip6AndPort) GetLo() uint64 {
	if m != nil {
		return m.Lo
	}
	return 0
}

func (m *Ip6AndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type NebulaPing struct {
	Type NebulaPing_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaPing_MessageType" json:"Type,omitempty"`
	Time uint64                 `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaPing) Reset()         { *m = NebulaPing{} }
func (m *NebulaPing) String() string { return proto.CompactTextString(m) }
func (*NebulaPing) ProtoMessage()    {}
func (*NebulaPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{5}
}
func (m *NebulaPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaPing.Merge(m, src)
}
func (m *NebulaPing) XXX_Size() int {
	return m.Size()
}
func (m *NebulaPing) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaPing.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaPing proto.InternalMessageInfo

func (m *NebulaPing) GetType() NebulaPing_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaPing_Ping
}

func (m *NebulaPing) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type NebulaHandshake struct {
	Details *NebulaHandshakeDetails `protobuf:"bytes,1,opt,name=Details,proto3" json:"Details,omitempty"`
	Hmac    []byte                  `protobuf:"bytes,2,opt,name=Hmac,proto3" json:"Hmac,omitempty"`
}

func (m *NebulaHandshake) Reset()         { *m = NebulaHandshake{} }
func (m *NebulaHandshake) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshake) ProtoMessage()    {}
func (*NebulaHandshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{6}
}
func (m *NebulaHandshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshake.Merge(m, src)
}
func (m *NebulaHandshake) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshake) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshake.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshake proto.InternalMessageInfo

func (m *NebulaHandshake) GetDetails() *NebulaHandshakeDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *NebulaHandshake) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

type NebulaHandshakeDetails struct {
	Cert           []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"Cert,omitempty"`
	InitiatorIndex uint32 `protobuf:"varint,2,opt,name=InitiatorIndex,proto3" json:"InitiatorIndex,omitempty"`
	ResponderIndex uint32 `protobuf:"varint,3,opt,name=ResponderIndex,proto3" json:"ResponderIndex,omitempty"`
	Cookie         uint64 `protobuf:"varint,4,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	Time           uint64 `protobuf:"varint,5,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaHandshakeDetails) Reset()         { *m = NebulaHandshakeDetails{} }
func (m *NebulaHandshakeDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshakeDetails) ProtoMessage()    {}
func (*NebulaHandshakeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{7}
}
func (m *NebulaHandshakeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshakeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshakeDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshakeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshakeDetails.Merge(m, src)
}
func (m *NebulaHandshakeDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshakeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshakeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshakeDetails proto.InternalMessageInfo

func (m *NebulaHandshakeDetails) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *NebulaHandshakeDetails) GetInitiatorIndex() uint32 {
	if m != nil {
		return m.InitiatorIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetResponderIndex() uint32 {
	if m != nil {
		return m.ResponderIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetCookie() uint64 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type NebulaControl struct {
	Type                NebulaControl_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaControl_MessageType" json:"Type,omitempty"`
	InitiatorRelayIndex uint32                    `protobuf:"varint,2,opt,name=InitiatorRelayIndex,proto3" json:"InitiatorRelayIndex,omitempty"`
	ResponderRelayIndex uint32                    `protobuf:"varint,3,opt,name=ResponderRelayIndex,proto3" json:"ResponderRelayIndex,omitempty"`
	RelayToIp           *Ip                       `protobuf:"bytes,4,opt,name=RelayToIp,proto3" json:"RelayToIp,omitempty"`
	RelayFromIp         *Ip                       `protobuf:"bytes,5,opt,name=RelayFromIp,proto3" json:"RelayFromIp,omitempty"`
}

func (m *NebulaControl) Reset()         { *m = NebulaControl{} }
func (m *NebulaControl) String() string { return proto.CompactTextString(m) }
func (*NebulaControl) ProtoMessage()    {}
func (*NebulaControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{8}
}
func (m *NebulaControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaControl.Merge(m, src)
}
func (m *NebulaControl) XXX_Size() int {
	return m.Size()
}
func (m *NebulaControl) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaControl.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaControl proto.InternalMessageInfo

func (m *NebulaControl) GetType() NebulaControl_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaControl_None
}

func (m *NebulaControl) GetInitiatorRelayIndex() uint32 {
	if m != nil {
		return m.InitiatorRelayIndex
	}
	return 0
}

func (m *NebulaControl) GetResponderRelayIndex() uint32 {
	if m != nil {
		return m.ResponderRelayIndex
	}
	return 0
}

func (m *NebulaControl) GetRelayToIp() *Ip {
	if m != nil {
		return m.RelayToIp
	}
	return nil
}

func (m *NebulaControl) GetRelayFromIp() *Ip {
	if m != nil {
		return m.RelayFromIp
	}
	return nil
}

func init() {
	proto.RegisterEnum("nebula.NebulaMeta_MessageType", NebulaMeta_MessageType_name, NebulaMeta_MessageType_value)
	proto.RegisterEnum("nebula.NebulaPing_MessageType", NebulaPing_MessageType_name, NebulaPing_MessageType_value)
	proto.RegisterEnum("nebula.NebulaControl_MessageType", NebulaControl_MessageType_name, NebulaControl_MessageType_value)
	proto.RegisterType((*NebulaMeta)(nil), "nebula.NebulaMeta")
	proto.RegisterType((*NebulaMetaDetails)(nil), "nebula.NebulaMetaDetails")
	proto.RegisterType((*Ip)(nil), "nebula.Ip")
	proto.RegisterType((*Ip4AndPort)(nil), "nebula.Ip4AndPort")
	proto.RegisterType((*Ip6AndPort)(nil), "nebula.Ip6AndPort")
	proto.RegisterType((*NebulaPing)(nil), "nebula.NebulaPing")
	proto.RegisterType((*NebulaHandshake)(nil), "nebula.NebulaHandshake")
	proto.RegisterType((*NebulaHandshakeDetails)(nil), "nebula.NebulaHandshakeDetails")
	proto.RegisterType((*NebulaControl)(nil), "nebula.NebulaControl")
}

func init() { proto.RegisterFile("nebula.proto", fileDescriptor_2d65afa7693df5ef) }

var fileDescriptor_2d65afa7693df5ef = []byte{
	// 726 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x8d, 0x1d, 0xe7, 0xef, 0xa6, 0x49, 0xfd, 0xdd, 0xea, 0x0b, 0x09, 0x12, 0x51, 0xb0, 0x10,
	0x8a, 0x10, 0x4a, 0xab, 0xb4, 0x54, 0x2c, 0x29, 0x41, 0x28, 0xa9, 0xda, 0x2a, 0x8c, 0x0a, 0x48,
	0x6c, 0xd0, 0xd4, 0x19, 0x1a, 0x2b, 0x89, 0xc7, 0xb5, 0x27, 0xa8, 0x79, 0x0b, 0x1e, 0x86, 0x87,
	0x60, 0xc1, 0xa2, 0x4b, 0x96, 0xa8, 0x5d, 0xb0, 0x60, 0xc9, 0x0b, 0xa0, 0x19, 0x3b, 0x8e, 0x93,
	0x86, 0xee, 0xe6, 0xce, 0x39, 0x67, 0x7c, 0xee, 0x99, 0x3b, 0x09, 0x6c, 0xb8, 0xec, 0x6c, 0x3a,
	0xa6, 0x2d, 0xcf, 0xe7, 0x82, 0x63, 0x36, 0xac, 0xac, 0xdf, 0x3a, 0xc0, 0x89, 0x5a, 0x1e, 0x33,
	0x41, 0xb1, 0x0d, 0xc6, 0xe9, 0xcc, 0x63, 0x55, 0xad, 0xa1, 0x35, 0xcb, 0xed, 0x7a, 0x2b, 0xd2,
	0x2c, 0x18, 0xad, 0x63, 0x16, 0x04, 0xf4, 0x9c, 0x49, 0x16, 0x51, 0x5c, 0xdc, 0x85, 0xdc, 0x2b,
	0x26, 0xa8, 0x33, 0x0e, 0xaa, 0x7a, 0x43, 0x6b, 0x16, 0xdb, 0xb5, 0xdb, 0xb2, 0x88, 0x40, 0xe6,
	0x4c, 0xeb, 0x8f, 0x06, 0xc5, 0xc4, 0x51, 0x98, 0x07, 0xe3, 0x84, 0xbb, 0xcc, 0x4c, 0x61, 0x09,
	0x0a, 0x5d, 0x1e, 0x88, 0x37, 0x53, 0xe6, 0xcf, 0x4c, 0x0d, 0x11, 0xca, 0x71, 0x49, 0x98, 0x37,
	0x9e, 0x99, 0x3a, 0xde, 0x87, 0x8a, 0xdc, 0x7b, 0xeb, 0x0d, 0xa8, 0x60, 0x27, 0x5c, 0x38, 0x9f,
	0x1c, 0x9b, 0x0a, 0x87, 0xbb, 0x66, 0x1a, 0x6b, 0xf0, 0xbf, 0xc4, 0x8e, 0xf9, 0x67, 0x36, 0x58,
	0x82, 0x8c, 0x39, 0xd4, 0x9f, 0xba, 0xf6, 0x70, 0x09, 0xca, 0x60, 0x19, 0x40, 0x42, 0xef, 0x87,
	0x9c, 0x4e, 0x1c, 0x33, 0x8b, 0x5b, 0xb0, 0xb9, 0xa8, 0xc3, 0xcf, 0xe6, 0xa4, 0xb3, 0x3e, 0x15,
	0xc3, 0xce, 0x90, 0xd9, 0x23, 0x33, 0x2f, 0x9d, 0xc5, 0x65, 0x48, 0x29, 0xe0, 0x03, 0xa8, 0xad,
	0x77, 0x76, 0x60, 0x8f, 0x4c, 0xb0, 0x7e, 0x69, 0xf0, 0xdf, 0xad, 0x50, 0xb0, 0x01, 0x99, 0x77,
	0x9e, 0xdb, 0xf3, 0x54, 0xea, 0xc5, 0x36, 0xcc, 0xe3, 0xeb, 0x79, 0x24, 0x04, 0x70, 0x0f, 0x8a,
	0x3d, 0x6f, 0xef, 0xc0, 0x1d, 0xf4, 0xb9, 0x2f, 0x64, 0xcc, 0xe9, 0x66, 0xb1, 0x8d, 0x0b, 0xde,
	0x1c, 0x22, 0x49, 0x5a, 0xa8, 0xda, 0x8f, 0x55, 0xc6, 0xaa, 0x6a, 0x3f, 0xa1, 0x8a, 0x69, 0xf8,
	0x04, 0x80, 0xb0, 0x31, 0x9d, 0x85, 0x96, 0x32, 0x4a, 0x94, 0xb4, 0x94, 0x40, 0xb1, 0x0a, 0x39,
	0x9b, 0x4f, 0x5d, 0xc1, 0xfc, 0x6a, 0xba, 0xa1, 0x35, 0x4b, 0x64, 0x5e, 0x5a, 0x8f, 0x40, 0xef,
	0x79, 0x58, 0x06, 0xbd, 0xeb, 0xa8, 0xb6, 0x0c, 0xa2, 0x77, 0x1d, 0x59, 0x1f, 0x71, 0x35, 0x25,
	0x06, 0xd1, 0x8f, 0xb8, 0xb5, 0x03, 0xb0, 0x30, 0x2c, 0xd1, 0x28, 0x84, 0x12, 0x91, 0x6a, 0x04,
	0x43, 0xee, 0x2b, 0x7e, 0x89, 0xa8, 0xb5, 0xf5, 0x42, 0x2a, 0xf6, 0x13, 0x8a, 0xbb, 0xce, 0x8f,
	0x4f, 0x48, 0x27, 0x4e, 0xb8, 0x9c, 0x0f, 0x7c, 0xdf, 0x71, 0xcf, 0xef, 0x1e, 0x78, 0xc9, 0x58,
	0x33, 0xf0, 0x08, 0xc6, 0xa9, 0x33, 0x61, 0xd1, 0x77, 0xd4, 0xda, 0xb2, 0x6e, 0x8d, 0xb3, 0x14,
	0x9b, 0x29, 0x2c, 0x40, 0x26, 0x1c, 0x0e, 0xcd, 0xfa, 0x08, 0x9b, 0xe1, 0xb9, 0x5d, 0xea, 0x0e,
	0x82, 0x21, 0x1d, 0x31, 0x7c, 0xbe, 0x78, 0x3b, 0xe1, 0xe5, 0xaf, 0x38, 0x88, 0x99, 0xab, 0x0f,
	0x48, 0x9a, 0xe8, 0x4e, 0xa8, 0xad, 0x4c, 0x6c, 0x10, 0xb5, 0xb6, 0xbe, 0x6a, 0x50, 0x59, 0xaf,
	0x93, 0xf4, 0x0e, 0xf3, 0x85, 0xfa, 0xca, 0x06, 0x51, 0x6b, 0x7c, 0x0c, 0xe5, 0x9e, 0xeb, 0x08,
	0x87, 0x0a, 0xee, 0xf7, 0xdc, 0x01, 0xbb, 0x8c, 0x92, 0x5e, 0xd9, 0x95, 0x3c, 0xc2, 0x02, 0x8f,
	0xbb, 0x03, 0x16, 0xf1, 0xc2, 0x3c, 0x57, 0x76, 0xb1, 0x02, 0xd9, 0x0e, 0xe7, 0x23, 0x87, 0x55,
	0x0d, 0x95, 0x4c, 0x54, 0xc5, 0x79, 0x65, 0x16, 0x79, 0x1d, 0x1a, 0xf9, 0xac, 0x99, 0x3b, 0x34,
	0xf2, 0x39, 0x33, 0x6f, 0x7d, 0xd7, 0xa1, 0x14, 0xda, 0xee, 0x70, 0x57, 0xf8, 0x7c, 0x8c, 0xcf,
	0x96, 0x6e, 0xe5, 0xe1, 0x72, 0x26, 0x11, 0x69, 0xcd, 0xc5, 0xec, 0xc0, 0x56, 0x6c, 0x5d, 0x4d,
	0x69, 0xb2, 0xab, 0x75, 0x90, 0x54, 0xc4, 0x4d, 0x24, 0x14, 0x61, 0x7f, 0xeb, 0x20, 0x6c, 0x42,
	0x41, 0x55, 0xa7, 0xbc, 0xe7, 0xa9, 0x3e, 0x97, 0x5f, 0xc7, 0x02, 0xc4, 0xa7, 0x50, 0x54, 0xc5,
	0x6b, 0x9f, 0x4f, 0xd4, 0x4b, 0x5a, 0xe5, 0x26, 0x61, 0xab, 0xfb, 0xaf, 0xdf, 0xc3, 0x0a, 0x60,
	0xc7, 0x67, 0x54, 0x30, 0xc5, 0x26, 0xec, 0x62, 0xca, 0x02, 0x61, 0x6a, 0x78, 0x0f, 0xb6, 0x96,
	0xf6, 0xa5, 0xd5, 0x80, 0x99, 0xfa, 0xcb, 0xdd, 0x6f, 0xd7, 0x75, 0xed, 0xea, 0xba, 0xae, 0xfd,
	0xbc, 0xae, 0x6b, 0x5f, 0x6e, 0xea, 0xa9, 0xab, 0x9b, 0x7a, 0xea, 0xc7, 0x4d, 0x3d, 0xf5, 0xa1,
	0x76, 0xee, 0x88, 0xe1, 0xf4, 0xac, 0x65, 0xf3, 0xc9, 0x76, 0x30, 0xa6, 0xf6, 0x68, 0x78, 0xb1,
	0x1d, 0xda, 0x39, 0xcb, 0xaa, 0xbf, 0x85, 0xdd, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5f, 0xae,
	0x26, 0x24, 0x26, 0x06, 0x00, 0x00,
}

func (m *NebulaMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaMetaDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMetaDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMetaDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelayVpnIp) > 0 {
		for iNdEx := len(m.RelayVpnIp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelayVpnIp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Ip6AndPorts) > 0 {
		for iNdEx := len(m.Ip6AndPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ip6AndPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Counter != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip4AndPorts) > 0 {
		for iNdEx := len(m.Ip4AndPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ip4AndPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.VpnIp != nil {
		{
			size, err := m.VpnIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Ip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lo != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Lo))
		i--
		dAtA[i] = 0x10
	}
	if m.Hi != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Hi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ip4AndPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ip4AndPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ip4AndPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Ip))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ip6AndPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ip6AndPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ip6AndPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if m.Lo != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Lo))
		i--
		dAtA[i] = 0x10
	}
	if m.Hi != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Hi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hmac) > 0 {
		i -= len(m.Hmac)
		copy(dAtA[i:], m.Hmac)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Hmac)))
		i--
		dAtA[i] = 0x12
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshakeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshakeDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshakeDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if m.Cookie != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Cookie))
		i--
		dAtA[i] = 0x20
	}
	if m.ResponderIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RelayFromIp != nil {
		{
			size, err := m.RelayFromIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.RelayToIp != nil {
		{
			size, err := m.RelayToIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ResponderRelayIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderRelayIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorRelayIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorRelayIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNebula(dAtA []byte, offset int, v uint64) int {
	offset -= sovNebula(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NebulaMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaMetaDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpnIp != nil {
		l = m.VpnIp.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	if len(m.Ip4AndPorts) > 0 {
		for _, e := range m.Ip4AndPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if m.Counter != 0 {
		n += 1 + sovNebula(uint64(m.Counter))
	}
	if len(m.Ip6AndPorts) > 0 {
		for _, e := range m.Ip6AndPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.RelayVpnIp) > 0 {
		for _, e := range m.RelayVpnIp {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	return n
}

func (m *Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hi != 0 {
		n += 1 + sovNebula(uint64(m.Hi))
	}
	if m.Lo != 0 {
		n += 1 + sovNebula(uint64(m.Lo))
	}
	return n
}

func (m *Ip4AndPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != 0 {
		n += 1 + sovNebula(uint64(m.Ip))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *Ip6AndPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hi != 0 {
		n += 1 + sovNebula(uint64(m.Hi))
	}
	if m.Lo != 0 {
		n += 1 + sovNebula(uint64(m.Lo))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *NebulaPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func (m *NebulaHandshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	l = len(m.Hmac)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaHandshakeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	if m.InitiatorIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorIndex))
	}
	if m.ResponderIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderIndex))
	}
	if m.Cookie != 0 {
		n += 1 + sovNebula(uint64(m.Cookie))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func (m *NebulaControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.InitiatorRelayIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorRelayIndex))
	}
	if m.ResponderRelayIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderRelayIndex))
	}
	if m.RelayToIp != nil {
		l = m.RelayToIp.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	if m.RelayFromIp != nil {
		l = m.RelayFromIp.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func sovNebula(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNebula(x uint64) (n int) {
	return sovNebula(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NebulaMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaMeta_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaMetaDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaMetaDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMetaDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMetaDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpnIp == nil {
				m.VpnIp = &Ip{}
			}
			if err := m.VpnIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip4AndPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip4AndPorts = append(m.Ip4AndPorts, &Ip4AndPort{})
			if err := m.Ip4AndPorts[len(m.Ip4AndPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6AndPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6AndPorts = append(m.Ip6AndPorts, &Ip6AndPort{})
			if err := m.Ip6AndPorts[len(m.Ip6AndPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayVpnIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayVpnIp = append(m.RelayVpnIp, &Ip{})
			if err := m.RelayVpnIp[len(m.RelayVpnIp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hi", wireType)
			}
			m.Hi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lo", wireType)
			}
			m.Lo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ip4AndPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ip4AndPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ip4AndPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ip6AndPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ip6AndPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ip6AndPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hi", wireType)
			}
			m.Hi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lo", wireType)
			}
			m.Lo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaPing_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaHandshakeDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hmac = append(m.Hmac[:0], dAtA[iNdEx:postIndex]...)
			if m.Hmac == nil {
				m.Hmac = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshakeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorIndex", wireType)
			}
			m.InitiatorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderIndex", wireType)
			}
			m.ResponderIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaControl_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorRelayIndex", wireType)
			}
			m.InitiatorRelayIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorRelayIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderRelayIndex", wireType)
			}
			m.ResponderRelayIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderRelayIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayToIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelayToIp == nil {
				m.RelayToIp = &Ip{}
			}
			if err := m.RelayToIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayFromIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelayFromIp == nil {
				m.RelayFromIp = &Ip{}
			}
			if err := m.RelayFromIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNebula(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNebula
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNebula
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNebula
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNebula        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNebula          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNebula = fmt.Errorf("proto: unexpected end of group")
)
